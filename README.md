# Bakery42
another attempt at creating my own kind of raspberry pi distributed computing

# Setup
To setup nodes in the network create a `.env` file containing the IP addresses of all the nodes you want to use. For ex:
```
NODE1=raspberry@192.168.1.101
NODE2=raspberry@192.168.1.102
NODE3=raspberry@192.168.1.103
NODE4=raspberry@192.168.1.104
```


## Network Test and A simple Program
So an instance I would like to use this for would be parsing as much of the log file data generated by my Titleist project. But first a simple test. 
```
>>> master = Master() # create a master node 
>>> master.test_network()
[+] NODE1 is connected
[+] NODE2 is connected
[+] NODE3 is connected
[+] NODE4 is connected

Jobs Verified:
{'NODE1': [True, 'local'], 'NODE2': [True, 'local'], 'NODE3': [True, 'local'], 'NODE4': [True, 'local']}
[~] Running jobs...
{'NODE1': {'jobs': ['python3 test.py'], 'args': [''], 'fileout': ''}, 'NODE2': {'jobs': ['python3 test.py'], 'args': [''], 'fileout': ''}, 'NODE3': {'jobs': ['python3 test.py'], 'args': [''], 'fileout': ''}, 'NODE4': {'jobs': ['python3 test.py'], 'args': [''], 'fileout': ''}}

 Executing: python3 /home/pi/Bakery42/test.py /home/pi/Bakery42/
 	Executing: python3 /home/pi/Bakery42/test.py /home/pi/Bakery42/
 	Executing: python3 /home/pi/Bakery42/test.py /home/pi/Bakery42/
 	Executing: python3 /home/pi/Bakery42/test.py /home/pi/Bakery42/
Waiting for machines to work...
[?] Waiting for output file /home/pi/result.txt
Connected to x.x.x.x.
RESULT:
Test file /home/pi/Bakery42/test.py was run on 8/23/2022 at 20:33:47
[?] Waiting for output file /home/pi/result.txt
Connected to x.x.x.x.
RESULT:
Test file /home/pi/Bakery42/test.py was run on 8/24/2022 at 1:33:47
[?] Waiting for output file /home/pi/result.txt
Connected to x.x.x.x
RESULT:
Test file /home/pi/Bakery42/test.py was run on 8/24/2022 at 1:33:49
[?] Waiting for output file /home/pi/result.txt
Connected to x.x.x.x.
RESULT:
Test file /home/pi/Bakery42/test.py was run on 8/24/2022 at 1:33:49
```

So now lets try something more customized. Lets say I want to parse a json log (present on master machine, not on remote node) using a python file called `log2json.py` also only present on master node. 
Using a simple JSON config, you can create a master, verify and then run the job:

```
>>> from workforce import *
>>> task = {'NODE1':{'jobs':['python3 log2json.py'],'args':['squatters.txt'],'fileout':['result.json']}}
>>> master.queue = master.determine_node_assignments(task)
>>> master.tasks_confirmed = master.verify_assignments()
[-] Verifying Jobs:
Connected to x.x.x.x.
Jobs Verified:
{'NODE1': [True, 'local']}
>>> master.run_tasks(12)
[~] Running jobs...
{'NODE1': {'jobs': ['python3 log2json.py'], 'args': ['squatters.txt'], 'fileout': ['result.json']}}
 	Executing: python3 /home/pi/Bakery42/log2json.py /home/pi/Bakery42/squatters.txt
Waiting for machines to work...
[?] Waiting for output file /home/pi/result.json
Connected to x.x.x.x.
RESULT:
{"entries": [[true, {"date_registered": ["08/11/22", "18:57:54"], "site_registered": "*.thumpar2.direct.quickconnect.to", "ip_address": "71.231.42.214"}], [true, {"date_registered": ["08/11/22", "18:57:55"], "site_registered": "*.semiotik.direct.quickconnect.to", "ip_address": "45.139.215.25"}], [true, {"date_registered": ["08/11/22", "18:57:56"], "site_registered": "*.samtan123.direct.quickconnect.to", "ip_address": "121.6.106.202"}], [true, {"date_registered": ["08/11/22", "18:58:02"], "site_registered": "test.partner.pik-digital.ru", "ip_address": "130.193.49.205"}], [true, {"date_registered": ["08/11/22", "18:58:06"], "site_registered": "*.zxcmnbasdlkjqwepoi.club", "ip_address": "43.240.29.20"}], [true, {"date_registered": ["08/11/22", "18:58:09"], "site_registered": "3f639017b279d66e20f34ae9cf6a867d.indubitably.xyz", "ip_address": "34.86.164.15"}], [true, {"date_registered": ["08/11/22", "18:58:11"], "site_registered": "*.thumpar2.direct.quickconnect.to", "ip_address": "71.231.42.214"}], [true, {"date_registered": ["08/11/22", "18:58:15"], "site_registered": "mail.whatsupband.ru", "ip_address": "185.215.4.20"}],....
```

*Nice! And the whole thing was done in ~10 seconds. Now using say 4-8 raspberry pi's I should be able to start parsing every domain registered in batches throughout the day, instead of trying to catch things as they are being registered in real time (too many bottlenecks, and missing malicious domains by checking against few domains to make code faster... gotta catch em all :D).* 
**Under Construction - Stay Tuned! ** 
